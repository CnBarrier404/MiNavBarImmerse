name: Auto Update Rules

on:
  issues:
    types: [opened, edited]

jobs:
  create-pr-for-rule-update:
    if: contains(github.event.issue.labels.*.name, '自动化请求') && contains(github.event.issue.labels.*.name, '规则更新')
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      issues: write

    steps:
      - name: Check issue body
        id: issue-body
        uses: actions/github-script@v7
        with:
          script: |
            const body = context.payload.issue.body;
            
            // 提取表单字段
            const extractField = (fieldName) => {
              const match = body.match(new RegExp(`### ${fieldName}\\s*\\n\\s*([^\\n]+)`));
              return match ? match[1].trim() : null;
            };
            
            const appName = extractField('应用名');
            const packageName = extractField('包名');
            const activityRule = extractField('Activity规则');
            const userEmail = extractField('您的邮箱');
            const description = body.match(/### 修改说明\\s*\\n\\s*([\\s\\S]+?)(?=###|$)/)?.[1]?.trim();
            
            if (!packageName || !activityRule) {
              core.setFailed('缺少必要的包名或Activity规则信息');
            }
            
            // 如果没有提供邮箱，使用GitHub noreply邮箱
            let finalEmail = userEmail;
            if (!finalEmail || finalEmail == "_No response_") {
              finalEmail = `${context.payload.issue.user.id}+${context.payload.issue.user.login}@users.noreply.github.com`;
            }
            
            return {
              appName,
              packageName, 
              activityRule, 
              userEmail: finalEmail,
              userName: context.payload.issue.user.login,
              description
            };

      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Create branch
        run: |
          branch_name="automation/update-rules-${{ github.event.issue.number }}"
          git checkout -b "$branch_name"
          echo "BRANCH_NAME=$branch_name" >> $GITHUB_ENV

      - name: Update XML file (safe edit with Python)
        id: update-xml
        env:
          PACKAGE_NAME: ${{ fromJSON(steps.issue-body.outputs.result).packageName }}
          ACTIVITY_RULE: ${{ fromJSON(steps.issue-body.outputs.result).activityRule }}
          APP_NAME: ${{ fromJSON(steps.issue-body.outputs.result).appName }}
        run: |
          set -euo pipefail
          PYTHONPATH=""
          xml_path="module/immerse_rules.xml"
          if [ ! -f "$xml_path" ]; then
            echo "Error: $xml_path not found"
            exit 1
          fi

          python3 - <<'PY'
          import os, sys
          from xml.etree import ElementTree as ET
          from xml.dom import minidom

          xml_path = os.path.join(os.getcwd(), "module", "immerse_rules.xml")
          pkg = os.environ.get("PACKAGE_NAME", "").strip()
          activity_rule = os.environ.get("ACTIVITY_RULE", "").strip()
          app = os.environ.get("APP_NAME", "").strip()

          if not pkg or not activity_rule:
              print("PACKAGE_NAME and ACTIVITY_RULE must be provided", file=sys.stderr)
              sys.exit(1)

          # Parse XML
          parser = ET.XMLParser(target=ET.TreeBuilder(insert_comments=True))
          tree = ET.parse(xml_path, parser=parser)
          root = tree.getroot()

          # Find package node (exact match on name)
          found = None
          for i, child in enumerate(list(root)):
              if child.tag == 'package' and child.get('name') == pkg:
                  found = (i, child)
                  break

          if found:
              idx, elem = found
              # update attributes
              elem.set('enable', 'true')
              elem.set('activityRule', activity_rule)
              # update or insert a comment immediately before the package if APP_NAME provided
              if app:
                  comment_text = f"{app} ({pkg})"
                  # check existing preceding comment
                  prev = None
                  if idx-1 >= 0:
                      prev = root[idx-1]
                      # xml.etree represents comments as ET.Comment nodes with tag 'comment' depending on parser, fallback to textual check
                      # To keep it robust, always insert a fresh comment before the package (avoid duplicates: remove any existing exact comment)
                      # remove duplicates that exactly match
                      # Iterate and remove any comment nodes whose text equals comment_text and which are immediately before this package
                      # Because handling comments in ElementTree is inconsistent across versions, attempt safe approach: remove adjacent comment if present
                      try:
                          # In this parser, comments are instances of ET.Comment (their tag is ET.Comment)
                          if isinstance(prev.tag, str) and prev.tag == ET.Comment:
                              if (prev.text or "").strip() == comment_text:
                                  pass  # already the expected comment
                      except Exception:
                          pass
                  # Insert comment before the package
                  root.insert(idx, ET.Comment(comment_text))
          else:
              # create and append new package (with optional comment before)
              new_pkg = ET.Element('package')
              new_pkg.set('name', pkg)
              new_pkg.set('enable', 'true')
              new_pkg.set('activityRule', activity_rule)
              if app:
                  root.append(ET.Comment(f"{app} ({pkg})"))
              root.append(new_pkg)

          # Pretty-print and write back
          rough_string = ET.tostring(root, encoding='utf-8')
          reparsed = minidom.parseString(rough_string)
          pretty = reparsed.toprettyxml(indent="  ", encoding='utf-8')

          with open(xml_path, "wb") as f:
              f.write(pretty)
          print("XML updated")
          PY

      - name: Commit changes (only if file changed)
        id: commit-changes
        env:
          ISSUE_AUTHOR_NAME: ${{ fromJSON(steps.issue-body.outputs.result).userName }}
          ISSUE_AUTHOR_EMAIL: ${{ fromJSON(steps.issue-body.outputs.result).userEmail }}
        run: |
          set -euo pipefail
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add module/immerse_rules.xml || true

          if git diff --staged --quiet --exit-code; then
            echo "CHANGES=false" >> $GITHUB_ENV
            echo "No changes to commit"
          else
            commit_message="Update rules based on issue #${{ github.event.issue.number }}"
            co_author_line="Co-authored-by: $ISSUE_AUTHOR_NAME <$ISSUE_AUTHOR_EMAIL>"
            git commit -m "$commit_message" -m "$co_author_line"
            git push -f -u origin automation/update-rules-${{ github.event.issue.number }}
            echo "CHANGES=true" >> $GITHUB_ENV
          fi

      - name: Create Pull Request
        id: create-pr
        if: env.CHANGES == 'true'
        uses: peter-evans/create-pull-request@v6
        with:
          title: "规则更新: ${{ fromJSON(steps.issue-body.outputs.result).packageName }}"
          body: |
            close #${{ github.event.issue.number }}

            由Issue #${{ github.event.issue.number }}自动生成
            
            修改内容:
            - 应用名: ${{ fromJSON(steps.issue-body.outputs.result).appName || '未提供' }}
            - 包名: ${{ fromJSON(steps.issue-body.outputs.result).packageName }}
            - 规则: ${{ fromJSON(steps.issue-body.outputs.result).activityRule }}
            - 说明: ${{ fromJSON(steps.issue-body.outputs.result).description || '无详细说明' }}
            
            此PR由自动化工作流创建
          branch: ${{ env.BRANCH_NAME }}
          base: main
          labels: |
            自动化
            更新规则

      - name: Associate PR with Issue
        if: steps.create-pr.outputs.pull-request-number != ''
        uses: actions/github-script@v7
        env:
          PULL_REQUEST_NUMBER: ${{ steps.create-pr.outputs.pull-request-number }}
        with:
          script: |
            const prNumber = process.env.PULL_REQUEST_NUMBER;
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: ${{ github.event.issue.number }},
              body: `已自动创建PR [#${prNumber}](https://github.com/${context.repo.owner}/${context.repo.repo}/pull/${prNumber}) 来处理此请求。`
            });
